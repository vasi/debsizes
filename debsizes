#!/usr/bin/env python
import apt_pkg
import sys
from collections import namedtuple

# Utility wrapper over apt_pkg.Cache
class Cache(object):
	def __init__(self):
		apt_pkg.init()
		self.cache = apt_pkg.Cache(progress = None)
	
	# Get the installed Version of a package
	def inst_vers(self, name):
		return self.cache[name].current_ver
	
	# List all installed Packages
	def installed(self):
		return [p for p in self.cache.packages
			if p.current_state == apt_pkg.CURSTATE_INSTALLED]
	
	# List manually installed Packages
	def keepers(self):
		dcache = apt_pkg.DepCache(self.cache)
		return [p for p in self.installed()
			if not dcache.is_auto_installed(p)]

# Dependency graph of packages
class DepGraph(object):
	DepTypesDepends = {'Depends', 'PreDepends'}
	DepTypesDefault = DepTypesDepends | {'Recommends'}
	DepTypesSuggests = DepTypesDefault | {'Suggests'}
	
	class Package(object):
		def __init__(self, pkg):
			self.vers = pkg.current_ver
			self.name = self.vers.parent_pkg.get_fullname(pretty = True)
			
			# Two-level array, groups of alternatives
			# eg: "foo | bar, qux" -> [[foo, bar], [qux]]
			self.deps = []
			
			self.rdeps = [] # Reverse deps, one alternative per group
			self.rsoft = [] # Includes very alternative
		
		def __hash__(self):
			return self.vers.id
		def __eq__(self, other):
			return self.__hash__() == other.__hash__()
		
		# Get recursive dependencies
		def rec_deps(self, soft = False):
			todo = [self]
			ret = set()
			while todo:
				p = todo.pop()
				if p in ret:
					continue
				ret.add(p)
				
				for ds in p.deps:
					dwant = ds if soft else [ds[0]]
					for d in dwant:
						todo.append(d)
			return ret
		
	def __init__(self, cache, deptypes = DepTypesDefault):
		self.cache = cache
		self.deptypes = deptypes
		
		self.packages = dict()
		for p in cache.installed():
			pkg = DepGraph.Package(p)
			self.packages[pkg.name] = pkg
		self.id2pkg = {p.vers.id: p
			for p in self.packages.itervalues()}
		
		# Fill in dependencies
		for p in self.packages.itervalues():
			p.deps = self._deps(p.vers)
			for ds in p.deps:
				ds[0].rdeps.append(p)
				for d in ds:
					d.rsoft.append(p)
	
	def by_id(self, i):
		return self.id2pkg[i]
	def by_vers(self, v):
		return self.by_id(v.id)
	
	# Calculate the dependency sets for a package
	def _deps(self, v):
		ret = []
		for dtype, deps in v.depends_list.iteritems():
			if not dtype in self.deptypes:
				continue
			for ordep in deps:
				alt = self._ordeps(ordep)
				if alt:
					ret.append(alt)
		return ret
	def _ordeps(self, ds):
		alt = []
		seen = set()
		for d in ds:
			for v in reversed(d.all_targets()):
				if v.id not in self.id2pkg:
					continue
				p = self.by_vers(v)
				if p not in seen:
					alt.append(p)
					seen.add(p)
		return alt
	
	def orphans(self):
		return [p for p in self.packages.itervalues()
			if not p.rdeps]
	def keepers(self):
		return [self.by_vers(p.current_ver)
			for p in self.cache.keepers()]

class DebSizer(object):
	def __init__(self, graph, roots = None):
		self.graph = graph
		self.base = []
		self.roots = roots or []
	
	Size = namedtuple('Size', 'package size')
	def sizes(self):
		rlist = list(self.roots)
		rsets = [p.rec_deps() for p in rlist]
		
		bset = set()
		for b in self.base:
			bset |= {d.vers.id for d in b.rec_deps()}

		counts = {}
		for rset in rsets:
			for i in (p.vers.id for p in rset):
				counts[i] = counts.get(i, 0) + 1
		
		rsize = []
		for rset in rsets:
			s = 0
			for r in rset:
				if r.vers.id not in bset:
					s += r.vers.installed_size / counts[r.vers.id]
			rsize.append(s)
		
		return [DebSizer.Size(r, rsize[i])
			for i, r in enumerate(rlist)]

if __name__ == "__main__":
	cache = Cache()
	graph = DepGraph(cache)
	sizer = DebSizer(graph, graph.keepers())
	sizer.base = [graph.packages['ubuntu-gnome-desktop']]
	sizes = sizer.sizes()
	sizes.sort(key = lambda x: x.size, reverse = True)
	for s in sizes:
		print "%12d  %s" % (s.size, s.package.name)
